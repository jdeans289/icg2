#include "utils.hpp"

#include <unordered_set> 

namespace ICGUtils {


    // Shamefully stolen from https://stackoverflow.com/questions/2896600/how-to-replace-all-occurrences-of-a-character-in-string
    // Do it in place
    void ReplaceAll_inplace(std::string& str, const std::string& from, const std::string& to) {
        size_t start_pos = 0;
        while((start_pos = str.find(from, start_pos)) != std::string::npos) {
            str.replace(start_pos, from.length(), to);
            start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
        }
    }

    /**
     * @brief Take a given typename and modify it so that it can be used in a variable name.
     * @note Types are often used as variable names in the code generated by ICG, so we need to
     *          create a version that follow variable name character rules and also won't collide with anything.
     *          Since these are in generated code, they don't have to be pretty, but they should be readable
     *          As a kindness to myself and future Trick developers
     * 
     * @param typename_to_modify 
     * @return std::string version of the type that can be used in a varname
     */
    std::string makeVarname(const std::string& typename_to_modify) {
        std::string result = typename_to_modify;

        ReplaceAll_inplace(result, "::", "_COLONS_");
        ReplaceAll_inplace(result, "<", "_LEFTANGLE_");
        ReplaceAll_inplace(result, ">", "_RIGHTANGLE_");
        ReplaceAll_inplace(result, ",", "_COMMA_");
        ReplaceAll_inplace(result, " ", "");

        return result;
    }

    std::string makeIOHeaderName (std::string header_name) {
        return "io_" + header_name;
    }

    bool isStlContainer (std::string some_typename) {
        const static std::unordered_set<std::string> container_names = {
            "std::vector",
            "std::list",
            "std::deque",
            "std::array",
            "std::forward_list",
            "std::queue",
            "std::priority_queue",
            "std::stack",
            "std::map",
            "std::set",
            "std::unordered_map",
            "std::unordered_set",
            "std::pair"
        };

        // chop off the template parameters
        // This assumes the fully qualified name
        int template_index = some_typename.find("<");
        if (template_index != std::string::npos) {
            some_typename = some_typename.substr(0, template_index);
        }

        return container_names.find(some_typename) != container_names.end();
    }

}